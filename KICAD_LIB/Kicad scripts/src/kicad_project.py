"""
Description:
Module responsible for holding information about KiCad projects

Inputs:
- String representing a path to a KiCad project

Outputs:
- A structure containing:
    - Pandas dataframes representing information about the system components
    - Various paths and names needed by the specific outputs 
- Writes temporary files to the file system and deletes them on exit
"""

import kicad_netlist_reader
import os
import pandas as pd
import shutil
import subprocess
import utils


class KiCad_Project:
    """
    KiCad_Project(pd) is a structure containing all important information about a
    KiCad project encompassed by project directory pd.

    Arguments:
        pd (str): the path to the directory containing the KiCad project to document

    Side Effects:
        Temporary/intermediate files are written to the file system

    Raises:
        FileNotFoundError if a KiCad project is not found in pd
    """

    def __init__(self, project_dir: str):
        # path to the directory with a KiCad project inside, relative to where
        # the python script was evoked
        self.PROJECT_DIR = project_dir

        # the name of the KiCad project (not a path)
        self.PROJECT_NAME = utils.get_kicad_project_name(self.PROJECT_DIR)

        if self.PROJECT_NAME is None:
            raise FileNotFoundError

        # path to the KiCad schematic file
        self.SCH_FILE = utils.find_file(
            self.PROJECT_NAME + ".kicad_sch", self.PROJECT_DIR
        )

        # path to the KiCad PCB file
        self.PCB_FILE = utils.find_file(
            self.PROJECT_NAME + ".kicad_pcb", self.PROJECT_DIR
        )

        # the directory to store documentation outputs
        self.DOCS_DIR = os.path.join(self.PROJECT_DIR, "docs")

        # the directory to store intermediate temporary files, to be deleted at the end
        self.TEMP_DIR = os.path.join(self.PROJECT_DIR, "temp")

        # create the directory structure for generating outputs
        os.makedirs(self.DOCS_DIR, exist_ok=True)
        os.makedirs(self.TEMP_DIR, exist_ok=True)

        # temporary netlist and position files needed to generate other outputs
        self.TEMP_NETLIST = os.path.join(self.TEMP_DIR, "temp_netlist.xml")
        self.TEMP_POS = os.path.join(self.TEMP_DIR, "temp_position.pos")
        self._write_temp_netlist()
        self._write_temp_pos_file()

        # a pandas dataframe containing one row per unique refdes in the schematic
        self.unique_refs_df = self._make_unique_refs_df()
        # a pandas dataframe with components grouped by part number as you'd see in a BOM
        self.grouped_by_val_df = self._make_grouped_by_val_dataframe(
            self.unique_refs_df
        )

    def cleanup_temp_files(self):
        """
        clean up the temporary netlist, pos files
        """
        print("Cleaning up temporary files")
        shutil.rmtree(self.TEMP_DIR)

    def _write_temp_netlist(self):
        """
        write a temporary XML netlist file as needed by the BOM step
        """
        # create netlist file from schematic
        subprocess.call(
            [
                "kicad-cli",
                "sch",
                "export",
                "netlist",
                "--output",
                self.TEMP_NETLIST,
                "--format",
                "kicadxml",
                self.SCH_FILE,
            ]
        )

    def _write_temp_pos_file(self):
        """
        write a temporary component position file as needed for pick-and-place files
        """
        # create position file from PCB
        subprocess.call(
            [
                "kicad-cli",
                "pcb",
                "export",
                "pos",
                "--output",
                self.TEMP_POS,
                "--format",
                "csv",
                "--units",
                "in",
                "--use-drill-file-origin",
                self.PCB_FILE,
            ]
        )

    def _make_unique_refs_df(self) -> pd.DataFrame:
        """
        _make_unique_refs_df() is a pandas dataframe with one row per unique refdes.

        The dataframe has columns for all of the information we have about a component,
        including ref, value, package, position, etc.

        Returns:
            pandas dataframe with one row per refdes.
        """
        # create a position dataframe from the .pos file generated by kicad-cli, we
        # will merge this with the main dataframe later
        pos_df = pd.read_csv(self.TEMP_POS)

        # read the netlist using the KiCad provided netlist reader
        net = kicad_netlist_reader.netlist(self.TEMP_NETLIST)
        components = net.getInterestingComponents(
            excludeBOM=True, excludeBoard=False, DNP=False
        )

        """
        The dataframe gets columns for each interesting component field. Fields
        are things like reference designator, value, footprint, etc.

        The dict below stores the names of the columns -> mapping functions
        which take components and yield the component's value for that column.
        More key/value pairs may be added to this dict if we want to add more
        fields, the for-loop below will automatically add new columns added here.

        Note that the KiCad symbols must be set up to have the specified fields
        below for this to work. The CCB KiCad libs on BitBucket are created to
        work with this script. For generic components you'll need to manually 
        add the 'Manufacturer', 'MPN', and 'Type' fields at least. Some fields
        are mandatory and automatic in KiCad (ref, val, footprint, some others)
        and others must be manually added.

        If new columns are added here, the CCB KiCad lib symbols will need to be
        updated with the new field as well.
        """
        field_name_to_mapping_func = {
            "Ref": (lambda c: c.getRef()),
            "Val": (lambda c: c.getValue()),
            # get rid of the unnecessary library info in the footprint name
            "Package": (lambda c: c.getFootprint().split(":")[-1]),
            "Description": (lambda c: c.getDescription()),
            "Manufacturer": (lambda c: c.getField("Manufacturer")),
            "MPN": (lambda c: c.getField("MPN")),
            "Type": (lambda c: c.getField("Type")),
            "DNP": (lambda c: "DNP" if c.getDNP() else ""),
            # count the number of pins in the component, ex: resistor has 2
            "Num pins": (lambda c: len(c.getLibPart().getPinList())),
        }

        unique_refs = pd.DataFrame(columns=field_name_to_mapping_func.keys())

        # create one row per component with unique refdes
        for c in components:
            row = [
                mapping_func(c) for mapping_func in field_name_to_mapping_func.values()
            ]

            # it's a bit inefficient to build the dataframe row-by-row this way. It is
            # better to allocate the whole dataframe upon creation and then fill in the cells.
            # But our BOMs are never going to be super huge in size so it doesn't matter too much.
            unique_refs.loc[len(unique_refs)] = row

        # merge in the position columns we got from processing the .pos file
        return unique_refs.merge(pos_df)

    def _make_grouped_by_val_dataframe(
        self, unique_refs_df: pd.DataFrame
    ) -> pd.DataFrame:
        """
        _make_grouped_by_val_dataframe(ur) is a pandas dataframe that is grouped by component value.

        Each unique component type gets a row, and each row has one or more refdes. The Ref column contains
        each refdes in the grouping, example: R1, R2, R5 are all 10k 0603 resistors and none are DNP, so they
        all go in the same row. This is like you'd typically see in a BOM.

        To be considered part of a group components must have identical values, footprints, and DNP status.

        Arguments:
            ur (pandas dataframe): a dataframe of component information with one row per refdes.

        Returns:
            pandas dataframe grouped by value, footprint, and DNP.
        """
        # group the BOM by components, so that each distinct component get a BOM line
        grouped = unique_refs_df.groupby(["Val", "Package", "DNP"])

        # this dataframe will have one row per unique part number
        grouped_by_val = pd.DataFrame(columns=unique_refs_df.columns)

        # TODO: there is probably a more pandas-y way to do this, what we want to do is
        # take the original dataframe with one row per refdes and squash identical components
        # into rows together. We also want the "Ref" column to be a list of all refs for that part,
        # and we add a quantity column as needed by most BOMs
        for group, frame in grouped:
            # choose the first element in the group for the grouped row, we might have just
            # one or there might be several components in the group
            grouped_by_val.loc[len(grouped_by_val)] = frame.iloc[0]

            if 1 < len(frame.values):
                # change the Ref name to be the list of all components in the group, ex: "R1, R2, R3"
                grouped_by_val.loc[len(grouped_by_val) - 1, "Ref"] = ", ".join(
                    frame["Ref"].values
                )

        # add quantity column to the grouped dataframe
        grouped_by_val["Quantity"] = grouped_by_val["Ref"].apply(
            # again, there is probably a more pandas way to do this than counting commas, but this works
            lambda refs: refs.count(",")
            + 1
        )

        return grouped_by_val
